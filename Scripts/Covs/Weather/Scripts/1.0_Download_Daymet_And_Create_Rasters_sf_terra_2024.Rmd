---
title: "1.0_Download_Daymet_And_Create_Rasters_sf_terra_2024.R"
output: html_document
date: "2024-08-09"
---

---
Title:    Disease Modeling Software 
          Script "1.0_Download_Daymet_and_Create_Rasters_sf_terra_2024.R" for Pennsylvania, USA

Authors:  Kristin J. Bondo, 
          Diego Montecino-Latorre, 
          W. David Walter
         
Date:    August 2024

Disclaimer: Any use of trade, firm, or product names is for descriptive purposes 
            only and does not imply endorsement by the U.S. Government.

Description: Section 1.0 of the script allows the user to download Daymet data, including daily minimum temperature, daily maximum temperature, daily precipitation, daily snow water equivalent, and other available data using the function “download_daymet_tiles” of the package “daymetr” for the study area, which consists of the entire state of Pennsylvania. Section 2.0 changes the downloaded raw files from .nc to .tif format and also makes a variable for mean temperature per day by averaging the minimum and maximum temperatures per day per 1 km grid cell resolution. Section 3.0 makes daily 5 km rasters of each variable by reprojecting the original 1 km rasters with the template grid of the study area, which has 5 km resolution. By default, the output contains 365 daily rasters for each year. In leap years, February 29 is not included. 

Save the downloaded files to a working directory with a large amount of storage space because these files are large when downloaded over large extents. 

This code was written under: 
R version 4.3.0 (2023-04-21) -- "Already Tomorrow"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin20 (64-bit)

---

Set-up: Set the working directory on your computer to the location that you would like to store the downloaded files, generate the dataset, and run the models.
```{r}

#For mac
mac_path <- "/your_working_directory"  #Change code to the working directory on your computer
set_working_directory(mac_path)

#For PC
pc_path <- "C:/your_working_directory" #Change code to the working directory on your computer
set_working_directory(pc_path)

# Define working directory
working.directory <- getwd() # Set working directory

```

Set-up: If not done previously, run the project set-up code below to make folders and sub-folders to organize and save data in subsequent scripts.
```{r}

# 0/ Specify overall project folder "Spatial_Disease_Modeling" to contain project files                                           
dir.create(paste0(getwd(),"/Weather_Modeling"))

# 1/ Make a sub-folder "1_Raw_Data" to store downloaded raw spatial data 
folder1 <- "Weather_Modeling/1_Raw_Data"
dir.create(file.path(working.directory, folder1), recursive=TRUE)

# 2/ Make a sub-folder "2_Spatial_Data_Ready_To_Use" to store the rasters with desired resolution that will be used in the modeling #
folder2 <- "Weather_Modeling/2_Spatial_Data_Ready_To_Use"
dir.create(file.path(working.directory, folder2), recursive=TRUE)

# 3/ Make a sub-folder "3_Data_Set_Prep" to store a copy of the cleaned data and extracted spatial data to attach to the dataset #
folder3 <- "Weather_Modeling/3_Data_Set_Prep"
dir.create(file.path(working.directory, folder3), recursive=TRUE)

# 4/ Make a sub-folder "4_Run_INLA_Model" to store saved output of INLA models #
folder4 <- "Weather_Modeling/4_Run_INLA_Models"
dir.create(file.path(working.directory, folder4), recursive=TRUE)

# 5/ Make a sub-folder "5_Predict_Surface" to store saved output of INLA models #
folder5 <- "Weather_Modeling/5_Predict_Surface"
dir.create(file.path(working.directory, folder5), recursive=TRUE)

# 6/ Make a sub-folder "6_Visualize_in_Shiny" to store saved output of INLA models #
folder6 <- "Weather_Modeling/6_Visualize_in_Shiny"
dir.create(file.path(working.directory, folder6), recursive=TRUE)

```

Set-Up: Check to see if required libraries are installed. If not, they will be installed.
```{r}

# List of required libraries
required_libraries <- c("foreach", "daymetr", "tigris", "lubridate", "sf", "terra")

# Function to check and install missing libraries
install_if_missing <- function(libraries) {
  for (lib in libraries) {
    if (!require(lib, character.only = TRUE)) {
      install.packages(lib, dependencies = TRUE)
    }
  }
}

# Install libraries
install_if_missing(required_libraries)

```

Set-up: Load packages after they are installed on your machine.
```{r}

library(foreach)
library(daymetr) #https://cran.r-project.org/web/packages/daymetr/vignettes/daymetr-vignette.html
library(tigris)
library(lubridate)
library(sf)
library(terra)

# Run these lines of code and then restart R to install the Daymet Package if the cran version has not been updated.
#if(!require(devtools)){install.packages("devtools")}
#devtools::install_github("bluegreen-labs/daymetr")
#library("daymetr")


```

1) Download select Daymet data of the study area for years 2017:2020. The tiles of the study area were determined from the Daymet webpage (https://daymet.ornl.gov/overview). (Click on supplementary files to view the map to identify the tiles for your study area).
```{r}

# Make a sub-folder in project directory to place raw Daymet data
sub_folder1 <- "Weather_Modeling/1_Raw_Data/Daymet"
dir.create(file.path(working.directory, sub_folder1), recursive=TRUE)

#' Daymet tiles for Pennsylvania, Maryland and New Jersey
tiles.final=c(11751, 11752, 11753, 11750, 11571, 11572, 11573, 11753, 11570)

nc_path <- file.path(working.directory, sub_folder1)

#Download Daily Minimum Temperature
for(i in 2022:2023){
  lapply(tiles.final, function(x)
    download_daymet_tiles(tiles = x,
                          start = i,
                          end = i,
                          param = "tmin",
                          path =  nc_path))
}

#Download Daily Maximum Temperature
for(i in 2022:2023){
  lapply(tiles.final, function(x)
    download_daymet_tiles(tiles = x,
                          start = i,
                          end = i,
                          param = "tmax",
                          path =  nc_path))

}

#Download Precipitation
for(i in 2022:2023){
  lapply(tiles.final, function(x)
    download_daymet_tiles(tiles = x,
                          start = i,
                          end = i,
                          param = "prcp",
                          path =  nc_path))
}

#Download Snow Water Equivalent
for(i in 2022:2023){
  lapply(tiles.final, function(x)
    download_daymet_tiles(tiles = x,
                          start = i,
                          end = i,
                          param = "swe",
                          path =  nc_path))
}


```

2) Function to generate a .tif per year from the Daymet .nc files. The resulting .tif files contain daily rasters for each year with a 1 km resolution across the study area.
```{r}

# Make a sub-folder in project directory to save variables as .tif per year
sub_folder2 <- "Weather_Modeling/1_Raw_Data/Daymet_tifs"
dir.create(file.path(working.directory, sub_folder2), recursive=TRUE)

# Years of data to build as .tif
years=c(2022:2023)

# List of files with the .nc termination
file_list <- list.files(file.path(working.directory, sub_folder1), pattern = '.*nc$')

# Define function to create Daymet variables as .tif per year across the study area
create.daymet.variables.per.year <- function(index.year, pattern) {
  
  # Filter the list based on the pattern
  file_list_2 <- grep(file_list, pattern = pattern, value = TRUE)
  
  # Further filter based on the year
  temp.files <- unlist(lapply(years[index.year], function(x) grep(file_list_2, pattern = x, value = TRUE)))
  
  # Prepare the raster layers
  all.prep <- lapply(temp.files, function(y) rast(file.path(working.directory, sub_folder1, y)))
  
  # Set CRS for each raster layer in projection of downloaded Daymet data
  crs_string <- "+proj=lcc +lat_1=25 +lat_2=60 +lat_0=42.5 +lon_0=-100 +x_0=0 +y_0=0 +ellps=WGS84 +units=m +no_defs"
  
  lapply(all.prep, function(r) crs(r) <- crs_string)
  
  # Merge layers
  temp <- lapply(1:nlyr(all.prep[[1]]), function(y) do.call(merge, lapply(all.prep, function(x) x[[y]])))
  
  final.i <- rast(temp)
  
  # Write the output raster
  writeRaster(final.i, file.path(working.directory, sub_folder2, paste0(pattern, "_", years[index.year], ".tif")), filetype = "GTiff", overwrite = TRUE)
}

```

2a) Generate a minimum temperature .tif per year 
```{r}

 foreach(i=seq_along(c(1:length(years))), .packages = "terra") %do% {
  
  create.daymet.variables.per.year(index.year=i,
                                   pattern="tmin")}

```

2b) Generate a maximum temperature .tif per year 
```{r}

foreach(i=seq_along(c(1:length(years))), .packages = "terra") %do% {
  
  create.daymet.variables.per.year(index.year=i,
                                   pattern="tmax")}

```

2c) Generate a mean temperature .tif per year constructed from minumum and maximum temperature tifs. (This step takes approximately two hours.)
```{r}

years <- c(2022:2023)

# Paths for tmax
#paths_max <- paste0("/Volumes/G-DRIVE ArmorATD/Spatial_Disease_Modeling/1_Raw_Data/Daymet_tifs/", "tmax_", years, ".tif")
paths_max <- file.path(working.directory, sub_folder2, paste0("tmax_", years, ".tif"))

# Paths for tmin
#paths_min <- paste0("/Volumes/G-DRIVE ArmorATD/Spatial_Disease_Modeling/1_Raw_Data/Daymet_tifs/", "tmin_", years, ".tif")
paths_min <- file.path(working.directory, sub_folder2, paste0("tmin_", years, ".tif"))

# Open tmax files
tmax.per.year <- lapply(paths_max, terra::rast)

# Make a single stack
tmax.full <- do.call(c, tmax.per.year)

# Open tmin files
tmin.per.year <- lapply(paths_min, terra::rast)

# Make a single stack
tmin.full <- do.call(c, tmin.per.year)

# List each layer of the tmin and tmax objects
tmax.each.day <- lapply(1:nlyr(tmax.full), function(x) tmax.full[[x]])
tmin.each.day <- lapply(1:nlyr(tmin.full), function(x) tmin.full[[x]])

tmean.per.year <- vector(mode = "list", length = length(years))

# Calculate the mean temperature per day .tif from daily minimum and maximum temperature rasters
for (i in 1:length(years)) {
  tmean.per.year[[i]] <- terra::rast(
    lapply(1:nlyr(tmax.per.year[[1]]), function(x) {
      tmax_layer <- tmax.per.year[[i]][[x]]
      tmin_layer <- tmin.per.year[[i]][[x]]
      terra::mean(c(tmax_layer, tmin_layer))
    })
  )
}

# Write the mean temperature per day .tif
lapply(1:length(tmean.per.year), function(x) {
  output_path <- file.path(working.directory, sub_folder2, paste0("tmean_", years[x], ".tif"))
  terra::writeRaster(tmean.per.year[[x]], output_path, overwrite = TRUE)
})

```

2d) Generate the precipitation .tif per year 
```{r}

foreach(i=seq_along(c(1:length(years))), .packages = "terra") %do% {
  
  create.daymet.variables.per.year(index.year=i,
                                   pattern="prcp")}

```

2e) Generate the snow water equivelant .tif per year 
```{r}

foreach(i=seq_along(c(1:length(years))), .packages = "terra") %do% {
  
  create.daymet.variables.per.year(index.year=i,
                                   pattern="swe")}

```

3) Construct rasters of each variable of 5 km resolution by first creating a template grid polygon of 5km resolution of the study area. 
```{r}

states <- tigris::states(resolution = "5m",
                         class = "sf",
                         progress_bar = FALSE)

sa.outline <- subset(states, states$STUSPS=="PA"|states$STUSPS=="MD"|states$STUSPS=="NJ")


template=st_buffer(st_transform(sa.outline, st_crs(5070)), dist = 10000) # template 10 km out of PA borders

# Create raster of specified resolution and projection

# Chosen resolution:
resolution=1000

ex <- as.vector(ext(template))

#Raster and Terra packages generate rasters differently. Raster adjusts ymin whereas terra adjusts ymax. Both adjust xmax. We calculate the extent to be same to how Raster package calculates it.

# Adjust xmax as both Raster and Terra Packages adjust
ncols <- (ex[2] - ex[1]) / resolution
ncols <- floor(ncols)  # Ensure whole number of columns
adjusted_xmax <- ex[1] + (ncols * resolution)  # Adjust xmax

# Adjust ymin as Raster package adjusts
nrows_raster <- (ex[4] - ex[3]) / resolution
nrows_raster <- floor(nrows_raster)  # Ensure whole number of rows
adjusted_ymin_raster <- ex[4] - (nrows_raster * resolution)  # Adjust ymin

#Generate raster to be same extent as raster package
grid.template <- rast(ext(ex[1], adjusted_xmax, adjusted_ymin_raster, ex[4]), 
                      res = resolution,
                      crs = "EPSG:5070") # Albers

#Generate raster using default method used by Terra package
#grid.template <-  rast(ext(template), 
                  #res = c(resolution),
                  #crs = "EPSG:6562") #nad83.2011.pa.north

# Code showing default method of how Terra package adjusts ymax 
#nrows_terra <- (ex[4] - ex[3]) / resolution
#nrows_terra <- floor(nrows_terra)  # Ensure whole number of rows
#adjusted_ymax_terra <- ex[3] + (nrows_terra * resolution)  # Adjust ymax

# Move template grid to a spatial object (before it was a empty raster)
gridPolygon <- as.polygons(grid.template)
gridPolygon_sf <- st_as_sf(gridPolygon)

# Subset the grid by the box created around PA. Now template is the gridpolygon 
template <- st_intersection(gridPolygon_sf, template)

# Add cell ID
templatelayer=c(1:nrow(template))
colnames(template)[1]="cell_number"
nrow(template) # 5546 cells.  

# Check point: plot the template, PA
plot(st_geometry(template))
plot(st_geometry(st_transform(sa.outline, st_crs(5070))), add=T, border="red", lwd=2)

```

3) Generate the 5km resolution rasters from the mean values of each environmental variable in each 5km grid cell of the grid polygon. The rasters are changed to a larger resolution by obtaining the weighted mean of each variable in the larger grid cell based on the values in the smaller grid cells and by accounting for the surface of the smaller grid cells that overlap the larger grid cells. The resulting 5 km rasters contain the mean values of each environmental variable.    

Set_Up: First create a sub-folder in project directory to save Daymet raster files with 5 km resolution
```{r}

sub_folder3 <- "Weather_Modeling/2_Spatial_Data_Ready_To_Use/DayMet_5KM_Rasters"
dir.create(file.path(working.directory, sub_folder3), recursive=TRUE)
```

3a) Generate daily 5km resolution rasters for mean temperature.
```{r}

# Years of interest
years <- 2022:2023

# Generate the paths for tmean files
paths <- file.path(working.directory, sub_folder2, paste0("tmean_", years, ".tif"))

# Open rasters. These are grouped per month (30 to 31 rasters per month depending on the month)
tmean.per.year=lapply(paths, function(x) rast(x))

# Reproject the raster as nad83.2011.pa.north and with the desired larger resolution (This step takes almost an hour to run)
tmean.repro.5km=lapply(tmean.per.year, function(y)
  lapply(c(1:nlyr(y)), function(x)
    project(y[[x]], grid.template, method='bilinear')))

# Flatten the list of lists into a single list
tmean.repro.5km <- do.call(c, lapply(tmean.repro.5km, unlist))

# Combine reprojected rasters
tmean.repro.5km <- rast(tmean.repro.5km)

# Mask rasters to the extent of the study area
tmean.repro.5km <- mask(tmean.repro.5km, template)

# Save the daily 5 km grid cell mean temperature rasters (365*4 = 1460 rasters)

# Get the number of layers
num_layers <- nlyr(tmean.repro.5km)

# Define output directory
output_dir <- file.path(working.directory, sub_folder3)

# Write each raster layer to a separate file
for (i in 1:num_layers) {
  output_path <- file.path(output_dir, paste0("daily_mean_temp_5km_all_PA_day_", i, ".tif"))
  
  terra::writeRaster(tmean.repro.5km[[i]], 
                     filename = output_path,
                     filetype = 'GTiff', 
                     overwrite = TRUE)
}

```

3b) Generate daily 5km resolution rasters for precipitation.
```{r}

# Years of interest
years <- 2022:2023

# Generate the paths for precip files
paths <- file.path(working.directory, sub_folder2, paste0("prcp_", years, ".tif"))

# Open rasters. These are grouped per month (30 to 31 rasters per month depending on the month)
precip.per.year=lapply(paths, function(x) rast(x))

# Reproject the raster as nad83.2011.pa.north and with the desired larger resolution (This step takes almost an hour to run)
precip.repro.5km=lapply(precip.per.year, function(y)
  lapply(c(1:nlyr(y)), function(x)
    project(y[[x]],  grid.template, method='bilinear')))

# Flatten the list of lists into a single list
precip.repro.5km <- do.call(c, lapply(precip.repro.5km, unlist))

# Combine reprojected rasters
precip.repro.5km <- rast(precip.repro.5km)

# Mask rasters to the extent of the study area
precip.repro.5km <- mask(precip.repro.5km, template)

# Save the daily 5 km grid cell precipitation rasters (365*4 = 1460 rasters)

# Get the number of layers
num_layers <- nlyr(precip.repro.5km)

# Define output directory
output_dir <- file.path(working.directory, sub_folder3)

# Write each raster layer to a separate file
for (i in 1:num_layers) {
  output_path <- file.path(output_dir, paste0("daily_mean_precip_5km_all_PA_day_", i, ".tif"))
  
  terra::writeRaster(tmean.repro.5km[[i]], 
                     filename = output_path,
                     filetype = 'GTiff', 
                     overwrite = TRUE)
}

```

3c) Generate daily 5km resolution rasters for snow water equivalent.
```{r}

# Years of interest
years <- 2022:2023

# Generate the paths for snow water equivalent files
paths <- file.path(working.directory, sub_folder2, paste0("swe_", years, ".tif"))

#paths=paste0("/Volumes/G-DRIVE ArmorATD/Spatial_Disease_Modeling/1_Raw_Data/Daymet_tifs/", paste0("swe_", c(2017:2020), ".tif")) # paths in the cluster
#paths=paste0("/Volumes/G-DRIVE ArmorATD/LaCie_Back_Up/Spatial_Disease_Modeling_old/1_Raw_Data/Daymet_tifs/", paste0("swe_", c(2017:2020), ".tif")) # paths in the cluster

# Open rasters. These are grouped per month (30 to 31 rasters per month depending on the month)
snow.per.year=lapply(paths, function(x) rast(x))

# Reproject the raster as nad83.2011.pa.north and with the desired larger resolution (This step takes almost an hour to run)
snow.repro.5km=lapply(snow.per.year, function(y)
  lapply(c(1:nlyr(y)), function(x)
    project(y[[x]],  grid.template, method='bilinear')))

# Flatten the list of lists into a single list
snow.repro.5km <- do.call(c, lapply(snow.repro.5km, unlist))

# Combine reprojected rasters
snow.repro.5km <- rast(snow.repro.5km)

# Mask to the extent of the study area
snow.repro.5km=mask(snow.repro.5km, template)

# Save the daily 5 km grid cell snow water equivalent rasters (365*4 = 1460 rasters)

# Get the number of layers
num_layers <- nlyr(snow.repro.5km)

# Define output directory
output_dir <- file.path(working.directory, sub_folder3)

# Write each raster layer to a separate file 
for (i in 1:num_layers) {
  output_path <- file.path(output_dir, paste0("daily_mean_snow_5km_all_PA_day_", i, ".tif"))
  
  terra::writeRaster(tmean.repro.5km[[i]], 
                     filename = output_path,
                     filetype = 'GTiff', 
                     overwrite = TRUE)
}

```

Checkpoint: Plot a single 5 km raster with the template grid of the study area. 
```{r}

# Define path to raster
raster_path <- file.path(working.directory, sub_folder3, "daily_mean_precip_5km_all_PA_day_1.tif")

# Load the raster file directly using the full path
newtest <- rast(raster_path)

plot(newtest)
plot(template, col=NA, add=T)
PA_transformed <- st_transform(sa.outline, st_crs(5070))
plot(st_geometry(PA_transformed), add=T, border="white")

```

